Garage is an internet of things garage door lock and opener for the raspberry pi. It uses nodejs and jwt to receive signed tokens to command a garage door to unlock and then trigger the opener. It's currently installed in my garage.

To do
I'm getting random notifications that the door is open when it is not. These are so infrequent they are difficult to measure. The input may be fluctuating due to high current draw on a cheap power supply pulling the supply voltage down. I'm currently testing with a different power supply.

General Info
When a token is verified and the open-close command is received, GPIO 17 (pin 11) will go active low to trigger the lock solenoid. Then GPIO 27 (pin 13) will go active low for half a second triggering the opener. 15 seconds later GPIO pin 17 will go inactive releasing the lock solenoid. You could use any GPIO pins, but these are right next to each other and a ground pin.

GPIO 22 (pin 15) will also trigger the lock and opener. This pin has an internal pull down. It is intended that this and 3v3 Power (pin 1) get connected to one's existing opener button to manually open/close. 

The lock is expected to work with a 120VAC solenoid and metal rod that will block the path of a garage door's rollers. 

A door magnet sensor detects when the garage door is opened for an unknown reason. The sensor is wired in the Normally Closed configuration. When the matching magnet moves away the circuit closes, pulling GPIO3 (pin 5) low. Open-Close timestamps are saved to a sqlite3 database. When a door open condition is detected that time is compared to the last open-close timestamp. If it has been more than 120 seconds it is assumed this shouldn't happen and a notification should be sent. We're using Twilio. In case the magnet is placed just at the threshold of detection, when SMS messages are sent are also timestamped. Any within 5 minutes of the last sent are ignored.

An iOS app has also been started which will generate keys, and send signed open-close requests. Presently keys must be generated elsewhere and the private key and other info saved to the app.

Needed info to setup:
API Key - random string of characters saved to ./keys/config.json
Each request needs this query parameter and will be checked first. This is mainly to keep lurkers away.

https keys - You can get these from https://letsencrypt.org. Set the path to these files in ./keys/config.json.

IP Address and port - to access the raspberry pi. If one's ip address isn't static a Dynamic Domain Name System service could be used instead. You'll also need to forward the port in your router and/or modem.

User ID - any integer to identify amongst multiple users.

Private, public rsa key generated by openssl (one per user). The private key is used to sign jwt tokens. The public key is used to verify the signature and should be installed in ./keys/ with a filename format of [USER_ID]-public.pem

A number of node packages are defined in package.json. Install them with `npm install`.

The database is expected to be read and written in the directory ./db/ . This directory must be created.

Relays and a solenoid. I found a board with two 5v relays locally similar to this: https://www.sainsmart.com/products/2-channel-5v-relay-module
When complete I'll include drawings and/or wiring diagrams.

This application can be run from the command line with `node app.js`

To generate a test token use `node genJwt.js [USERID] [COMMAND]`. From a web browser the url takes the format: "https://[IP]:[PORT]/api/garage?apikey=[API_KEY]&token=[JWT]"
A response including the word 'verify' is successful. The payload of the jwt has the following format: `{"uid": 1, "command": "verify", "iat": TIMESTAMP}` 

Security info:
We're using jwt tokens with the RS256 algorithm for extra security. A private key signs tokens for which verification can only be done with the matching public key. Tokens older than two minutes are rejected. Even if one were to get a copy of a token it would soon be invalid. Communicating over https provides further protection. New ssl cert files can be generated by running certbot and updating certbot.js
certbot command example:
`sudo letsencrypt certonly --manual --email [YOUR EMAIL] -d [DOMAIN]`

./keys/config.json uses the following format:
{
  "rpi": false,
  "apiKey":  "API KEY string",
  "authToken": "TWILIO AUTH TOKEN",
  "accountSid": "TWILIO ACCOUNT SID",
  "from": "FROM TWILIO NUMBER",
  "to": "PHONE NUMBER TO SEND SMS",
  "keyPath": "LOCAL PATH TO SSL CERT FILES"
}